	}

	create := createInstanceHandler(db)
	req := httptest.NewRequest(http.MethodPost, "/api/instances", strings.NewReader(`{"name":"A","loader":"fabric","serverId":"missing"}`))
	w := httptest.NewRecorder()
	create(w, req)
	if w.Code != http.StatusBadRequest {
		t.Fatalf("expected 400, got %d", w.Code)
	}
	var count int
	db.QueryRow(`SELECT COUNT(*) FROM instances`).Scan(&count)
	if count != 1 {
		t.Fatalf("expected 1 row, got %d", count)
	}
}

func TestInstanceNameValidation(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()

	origGet := ppGetServer
	origList := ppListPath
	defer func() { ppGetServer = origGet; ppListPath = origList }()
	ppGetServer = func(ctx context.Context, id string) (*pppkg.ServerDetail, error) {
		return &pppkg.ServerDetail{ID: id, Name: "Srv", Environment: struct {
			Type string `json:"type"`
		}{Type: "fabric"}}, nil
	}
	ppListPath = func(ctx context.Context, serverID, path string) ([]pppkg.FileEntry, error) { return nil, nil }

	create := createInstanceHandler(db)
	for _, n := range []string{"", "   "} {
		req := httptest.NewRequest(http.MethodPost, "/api/instances", strings.NewReader(fmt.Sprintf(`{"name":%q,"loader":"fabric","serverId":"1"}`, n)))
		w := httptest.NewRecorder()
		create(w, req)
		if w.Code != http.StatusBadRequest {
			t.Fatalf("expected 400 for %q, got %d", n, w.Code)
		}
	}
	longName := strings.Repeat("a", dbpkg.InstanceNameMaxLen+1)
	req := httptest.NewRequest(http.MethodPost, "/api/instances", strings.NewReader(fmt.Sprintf(`{"name":%q,"loader":"fabric","serverId":"1"}`, longName)))
	w := httptest.NewRecorder()
	create(w, req)
	if w.Code != http.StatusBadRequest {
		t.Fatalf("expected 400 for long name, got %d", w.Code)
	}

	inst := dbpkg.Instance{Name: "ok", Loader: "fabric", EnforceSameLoader: true}
	if err := dbpkg.InsertInstance(db, &inst); err != nil {
		t.Fatalf("insert inst: %v", err)
	}
	update := updateInstanceHandler(db)
	reqU := httptest.NewRequest(http.MethodPut, fmt.Sprintf("/api/instances/%d", inst.ID), strings.NewReader(`{"name":" "}`))
	rctx := chi.NewRouteContext()
	rctx.URLParams.Add("id", strconv.Itoa(inst.ID))
	reqU = reqU.WithContext(context.WithValue(context.Background(), chi.RouteCtxKey, rctx))
	wU := httptest.NewRecorder()
	update(wU, reqU)
	if wU.Code != http.StatusBadRequest {
		t.Fatalf("expected 400 on update, got %d", wU.Code)
	}
}

func TestSyncHandler_ScansMods(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()

	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch {
		case r.URL.Path == "/oauth2/token":
			fmt.Fprint(w, `{"access_token":"tok","expires_in":3600}`)
		case r.URL.Path == "/api/servers/1":
			fmt.Fprint(w, `{"id":"1","name":"Srv","environment":{"type":"fabric"}}`)
		case r.URL.Path == "/api/servers/1/file/mods%2F":
			fmt.Fprint(w, `[{"name":"mod.jar","is_dir":false},{"name":"other.txt","is_dir":false}]`)
		default:
			http.NotFound(w, r)
		}
	}))
	defer srv.Close()

	_, _, _ = initSecrets(t, db)
	if err := pppkg.Set(pppkg.Credentials{BaseURL: srv.URL, ClientID: "id", ClientSecret: "secret"}); err != nil {
		t.Fatalf("set creds: %v", err)
	}
	inst := dbpkg.Instance{Name: "Inst", Loader: "", EnforceSameLoader: true}
	if err := dbpkg.InsertInstance(db, &inst); err != nil {
		t.Fatalf("insert inst: %v", err)
	}
	h := syncHandler(db)
	body := `{"serverId":"1"}`
	req := httptest.NewRequest(http.MethodPost, fmt.Sprintf("/api/instances/%d/sync", inst.ID), strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	rctx := chi.NewRouteContext()
	rctx.URLParams.Add("id", strconv.Itoa(inst.ID))
	req = req.WithContext(context.WithValue(req.Context(), chi.RouteCtxKey, rctx))
	w := httptest.NewRecorder()
	h(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("status %d", w.Code)
	}
	var resp struct {
		ID     int    `json:"id"`
		Status string `json:"status"`
	}
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatalf("decode: %v", err)
	}
	if resp.Status != JobQueued {
		t.Fatalf("unexpected status %s", resp.Status)
	}
	job := waitJob(t, db, resp.ID)
	if job.Status != JobSucceeded {
		t.Fatalf("final status %s", job.Status)
	}
	mods, err := dbpkg.ListMods(db, inst.ID)
	if err != nil {
		t.Fatalf("list mods: %v", err)
	}
	if len(mods) != 0 {
		t.Fatalf("expected no mods, got %d", len(mods))
	}
}

func TestSyncHandler_MissingFolder(t *testing.T) {
	t.Skip("TODO: update for job queue")
}

func TestSyncHandler_MatchesMods(t *testing.T) {
	t.Skip("TODO: update for job queue")
}

func TestSyncHandler_DeepScanMatches(t *testing.T) {
	t.Skip("TODO: update for job queue")
}

func TestSyncHandler_Validation(t *testing.T) {
	t.Skip("TODO: update for job queue")
}

func TestSyncHandler_UsesStoredServerID(t *testing.T) {
	t.Skip("TODO: update for job queue")
}

func TestPufferpanelTestEndpointPostOnly(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()
	svc, _, _ := initSecrets(t, db)
	h := New(db, os.DirFS("."), svc)

	req := httptest.NewRequest(http.MethodGet, "/api/pufferpanel/test", nil)
	w := httptest.NewRecorder()
	h.ServeHTTP(w, req)
	if w.Code != http.StatusNotFound {
		t.Fatalf("status %d", w.Code)
	}
}

func TestSyncRoutesPostOnly(t *testing.T) {
	prev := allowResyncAlias
	allowResyncAlias = true
	t.Cleanup(func() { allowResyncAlias = prev })
	db := openTestDB(t)
	defer db.Close()
	svc, _, _ := initSecrets(t, db)
	h := New(db, os.DirFS("."), svc)

	req := httptest.NewRequest(http.MethodGet, "/api/instances/1/resync", nil)
	w := httptest.NewRecorder()
	h.ServeHTTP(w, req)
	if w.Code != http.StatusMethodNotAllowed {
		t.Fatalf("status %d", w.Code)
	}

	req = httptest.NewRequest(http.MethodGet, "/api/instances/1/sync", nil)
	w = httptest.NewRecorder()
	h.ServeHTTP(w, req)
	if w.Code != http.StatusMethodNotAllowed {
		t.Fatalf("status %d", w.Code)
	}
