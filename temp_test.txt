
func (matchClient) Search(ctx context.Context, query string) (*mr.SearchResult, error) {
	return &mr.SearchResult{Hits: []struct {
		ProjectID string `json:"project_id"`
		Slug      string `json:"slug"`
		Title     string `json:"title"`
	}{{ProjectID: "1", Slug: "sodium", Title: "Sodium"}}}, nil
}

func TestCreateModHandler_EnforceLoader(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()

	inst := &dbpkg.Instance{Name: "A", Loader: "fabric", EnforceSameLoader: true}
	if err := dbpkg.InsertInstance(db, inst); err != nil {
		t.Fatalf("insert instance: %v", err)
	}

	h := createModHandler(db)

	payload := `{"url":"https://modrinth.com/mod/sodium","game_version":"1.20","loader":"forge","channel":"release","instance_id":` + strconv.Itoa(inst.ID) + `}`
	req := httptest.NewRequest(http.MethodPost, "/api/mods", strings.NewReader(payload))
	w := httptest.NewRecorder()

	h(w, req)

	if w.Code != http.StatusBadRequest {
		t.Fatalf("status %d", w.Code)
	}
	var errResp httpx.Error
	if err := json.NewDecoder(w.Body).Decode(&errResp); err != nil {
		t.Fatalf("decode: %v", err)
	}
	if errResp.Message != "loader mismatch" {
		t.Fatalf("want loader mismatch, got %q", errResp.Message)
	}
}

func TestListModsHandler_ScopeAndCache(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()

	inst1 := &dbpkg.Instance{Name: "A", Loader: "fabric"}
	if err := dbpkg.InsertInstance(db, inst1); err != nil {
		t.Fatalf("insert inst1: %v", err)
	}
	inst2 := &dbpkg.Instance{Name: "B", Loader: "forge"}
	if err := dbpkg.InsertInstance(db, inst2); err != nil {
		t.Fatalf("insert inst2: %v", err)
	}

	if err := dbpkg.InsertMod(db, &dbpkg.Mod{Name: "M1", URL: "u1", InstanceID: inst1.ID}); err != nil {
		t.Fatalf("insert mod1: %v", err)
	}
	if err := dbpkg.InsertMod(db, &dbpkg.Mod{Name: "M2", URL: "u2", InstanceID: inst2.ID}); err != nil {
		t.Fatalf("insert mod2: %v", err)
	}

	h := listModsHandler(db)
	req := httptest.NewRequest(http.MethodGet, "/api/mods?instance_id="+strconv.Itoa(inst1.ID), nil)
	w := httptest.NewRecorder()
	h(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("status %d", w.Code)
	}
	if cc := w.Header().Get("Cache-Control"); cc != "max-age=60" {
		t.Fatalf("cache-control %q", cc)
	}
	var mods []dbpkg.Mod
	if err := json.NewDecoder(w.Body).Decode(&mods); err != nil {
		t.Fatalf("decode: %v", err)
	}
	if len(mods) != 1 || mods[0].InstanceID != inst1.ID {
		t.Fatalf("unexpected mods: %v", mods)
	}
}

func TestInstanceHandlers_CRUD(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()

	// stub PufferPanel interactions
	origGet := ppGetServer
	origList := ppListPath
	defer func() { ppGetServer = origGet; ppListPath = origList }()
	ppGetServer = func(ctx context.Context, id string) (*pppkg.ServerDetail, error) {
		return &pppkg.ServerDetail{ID: id, Name: "Srv", Environment: struct {
			Type string `json:"type"`
		}{Type: "fabric"}}, nil
	}
	ppListPath = func(ctx context.Context, serverID, path string) ([]pppkg.FileEntry, error) { return nil, nil }

	create := createInstanceHandler(db)
	req := httptest.NewRequest(http.MethodPost, "/api/instances", strings.NewReader(`{"name":"A","loader":"fabric","serverId":"1"}`))
	w := httptest.NewRecorder()
	create(w, req)
	if w.Code != http.StatusCreated {
		t.Fatalf("create status %d", w.Code)
	}
	var inst dbpkg.Instance
	if err := json.NewDecoder(w.Body).Decode(&inst); err != nil {
		t.Fatalf("decode create: %v", err)
	}

	// Update instance name
	update := updateInstanceHandler(db)
	payload := `{"name":"A2"}`
	req3 := httptest.NewRequest(http.MethodPut, "/api/instances/"+strconv.Itoa(inst.ID), strings.NewReader(payload))
	rctx := chi.NewRouteContext()
	rctx.URLParams.Add("id", strconv.Itoa(inst.ID))
	req3 = req3.WithContext(context.WithValue(req3.Context(), chi.RouteCtxKey, rctx))
	w3 := httptest.NewRecorder()
	update(w3, req3)
	if w3.Code != http.StatusOK {
		t.Fatalf("update status %d", w3.Code)
	}

	// Delete instance
	deleteH := deleteInstanceHandler(db)
	req4 := httptest.NewRequest(http.MethodDelete, "/api/instances/"+strconv.Itoa(inst.ID), nil)
	rctx4 := chi.NewRouteContext()
	rctx4.URLParams.Add("id", strconv.Itoa(inst.ID))
	req4 = req4.WithContext(context.WithValue(req4.Context(), chi.RouteCtxKey, rctx4))
	w4 := httptest.NewRecorder()
	deleteH(w4, req4)
	if w4.Code != http.StatusNoContent {
		t.Fatalf("delete status %d", w4.Code)
	}
}

func TestValidateAndCreateInstance(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()

	// stub pufferpanel functions
	origGet := ppGetServer
	origList := ppListPath
	defer func() {
		ppGetServer = origGet
		ppListPath = origList
	}()
	ppGetServer = func(ctx context.Context, id string) (*pppkg.ServerDetail, error) {
		return &pppkg.ServerDetail{ID: id, Name: "Srv", Environment: struct {
			Type string `json:"type"`
		}{Type: "fabric"}}, nil
	}
	ppListPath = func(ctx context.Context, serverID, path string) ([]pppkg.FileEntry, error) {
		return nil, nil
	}

	validate := validateInstanceHandler()
	reqV := httptest.NewRequest(http.MethodPost, "/api/instances/validate", strings.NewReader(`{"name":"A","loader":"fabric","serverId":"1"}`))
	wV := httptest.NewRecorder()
	validate(wV, reqV)
	if wV.Code != http.StatusOK {
		t.Fatalf("validate status %d", wV.Code)
	}

	create := createInstanceHandler(db)
	reqC := httptest.NewRequest(http.MethodPost, "/api/instances", strings.NewReader(`{"name":"A","loader":"fabric","serverId":"1"}`))
	wC := httptest.NewRecorder()
	create(wC, reqC)
	if wC.Code != http.StatusCreated {
		t.Fatalf("create status %d", wC.Code)
	}
	var inst dbpkg.Instance
	if err := json.NewDecoder(wC.Body).Decode(&inst); err != nil {
		t.Fatalf("decode create: %v", err)
	}
	if inst.Name != "A" || inst.ID == 0 {
		t.Fatalf("unexpected instance %+v", inst)
	}
	var count int
	if err := db.QueryRow(`SELECT COUNT(*) FROM instances`).Scan(&count); err != nil {
		t.Fatalf("count: %v", err)
	}
	if count != 2 {
		t.Fatalf("expected 2 rows, got %d", count)
	}
}

func TestCreateInstance_InvalidServer(t *testing.T) {
	db := openTestDB(t)
	defer db.Close()

	origGet := ppGetServer
	defer func() { ppGetServer = origGet }()
	ppGetServer = func(ctx context.Context, id string) (*pppkg.ServerDetail, error) {
		return nil, pppkg.ErrNotFound
	}
